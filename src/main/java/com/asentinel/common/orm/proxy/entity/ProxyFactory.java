package com.asentinel.common.orm.proxy.entity;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

import org.springframework.util.ReflectionUtils;

import com.asentinel.common.jdbc.DefaultObjectFactory;
import com.asentinel.common.jdbc.ObjectFactory;
import com.asentinel.common.orm.Entity;
import com.asentinel.common.orm.TargetMember;
import com.asentinel.common.orm.TargetMembersHolder;
import com.asentinel.common.orm.proxy.Proxy;
import com.asentinel.common.orm.proxy.ProxyFactorySupport;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.dynamic.DynamicType.Builder;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.matcher.ElementMatcher;
import net.bytebuddy.matcher.ElementMatchers;

/**
 * Singleton, the only instance can be obtained using the {@link #getInstance()} method.
 * This class is in essence a map with the following characteristics:
 * <li> the key is the target class (the class to be instrumented/proxied);
 * <li> the value is a {@link ObjectFactory} that can create proxy instances.
 * <br><br> 
 * Proxies generated by this class are serializable if the proxied class is serializable and it defines
 * a {@code serialVersionUid}. However the client of the proxy is responsible for loading the proxy before 
 * serialization ((call a method other than {@code Object#toString()}) or the id getter/setter). On deserialization 
 * the client of the proxy must ensure that the proxy class is loaded by calling {@link ProxyFactory#getProxyObjectFactory(Class)};
 * <br><br>
 * This class should not be used directly by any client code except for loading a proxied class that is needed for
 * deserialization.
 * 
 * @see #newProxy(Class, Function)
 * @see ProxyFactorySupport
 * @see LazyLoadInterceptor
 *  
 * @author Razvan Popian
 */
public final class ProxyFactory extends ProxyFactorySupport {
	
	private final static ProxyFactory proxyFactory = new ProxyFactory();
	
	private final LazyLoadInterceptor lazyLoadInterceptor = new LazyLoadInterceptor();
	private final ToStringInterceptor toStringInterceptor = new ToStringInterceptor();
	
	
	public static ProxyFactory getInstance() {
		return proxyFactory;
	}
	
	
	/**
	 * Private constructor.
	 * Use {@link #getInstance()} for accessing the singleton instance of this class.
	 */
	private ProxyFactory() {
		
	}
	
	@Override
	@SuppressWarnings("unchecked")
	protected <T> DefaultObjectFactory<? extends T> getProxyObjectFactoryInternal(Class<T> clazz) {
		ElementMatcher<? super MethodDescription> matcher;
		if (Entity.class.isAssignableFrom(clazz)) {
			matcher = ElementMatchers.not(ElementMatchers.isOverriddenFrom(Entity.class));
		} else {
			TargetMember pkTargetMember = TargetMembersHolder.getInstance().getTargetMembers(clazz).getPkColumnMember();
			if (pkTargetMember == null) {
				throw new IllegalStateException("Dynamic proxying is not supported for class " + clazz +
						", because no primary key member exists.");
			}
			List<Method> excluded = new ArrayList<>(2);
			Method pkGetter = pkTargetMember.getGetMethod();
			if (pkGetter != null) {
				excluded.add(pkGetter);
			}
			Method pkSetter = pkTargetMember.getSetMethod();
			if (pkSetter != null) {
				excluded.add(pkSetter);
			}
			if (excluded.isEmpty()) {
				if (pkTargetMember.getAnnotatedElement() instanceof Method) {
					throw new IllegalStateException("Dynamic proxying is not supported for class " 
							+ clazz + ", because no getter or setter method can be found for the id.");
				}
				matcher = ElementMatchers.any();
			} else {
				matcher = ElementMatchers.noneOf(excluded.toArray(new Method[excluded.size()]));
			}
		}
		
		DefaultObjectFactory<? extends T> proxyFactory = (DefaultObjectFactory<? extends T>) cache.get(clazz,
			() -> {
				checkForFinalMethods(clazz);
				Builder<?> byteBuddyBuilder = new ByteBuddy()
					.subclass(clazz)
					.name(clazz.getPackage().getName() + "." + clazz.getSimpleName() + PROXY_CLASS_NAME_SUFFIX)
					// Implementation note: the loader field MUST be volatile, because it can potentially 
					// be set/read from multiple threads. The visibility of the lazy loaded fields
					// is ensured by synchronizing on the proxy implicit lock (see AbstractLazyLoadInterceptor and AbstractToStringInterceptor), 
					// but the loader field can be set without acquiring a lock first, for example by the method #newProxy(Class, Function) 
					// in this class.
					.defineField(LOADER_FIELD_NAME, Function.class, HELPER_FIELD_MODIFIERS)
					.implement(Proxy.class)
					.method(matcher)
					.intercept(MethodDelegation.withDefaultConfiguration().filter(ElementMatchers.named(INTERCEPTOR_METHOD_NAME)).to(lazyLoadInterceptor))
					.method(ElementMatchers.isToString())
					.intercept(MethodDelegation.withDefaultConfiguration().filter(ElementMatchers.named(TO_STRING_INTERCEPTOR_METHOD_NAME)).to(toStringInterceptor));
				
				Long serialVersionUid = getSerialVersionUid(clazz);
				if (serialVersionUid != null) {
					byteBuddyBuilder = byteBuddyBuilder.serialVersionUid(serialVersionUid);
				}
				
				return newObjectFactory(byteBuddyBuilder, clazz);
			}
		);
		return proxyFactory;
	}
	
	
	public <T> T newProxy(Class<T> targetClass, Function<Object, T> loader) {
		DefaultObjectFactory<? extends T> proxyFactory = getProxyObjectFactory(targetClass);
		T proxy = proxyFactory.newObject();
		Field loaderField = findLoaderField(proxyFactory.getType());
		ReflectionUtils.setField(loaderField, proxy, loader);
		return proxy;
	}
	
}