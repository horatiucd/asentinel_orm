package com.asentinel.common.orm.proxy.collection;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Function;

import org.springframework.util.ReflectionUtils;

import com.asentinel.common.jdbc.DefaultObjectFactory;
import com.asentinel.common.jdbc.ObjectFactory;
import com.asentinel.common.orm.proxy.Proxy;
import com.asentinel.common.orm.proxy.ProxyFactorySupport;
import com.asentinel.common.orm.proxy.entity.LazyLoadInterceptor;
import com.asentinel.common.util.Assert;

import net.bytebuddy.ByteBuddy;
import net.bytebuddy.dynamic.DynamicType.Builder;
import net.bytebuddy.implementation.MethodDelegation;
import net.bytebuddy.matcher.ElementMatchers;

/**
 * Factory for collection proxies. It is a singleton, the only instance can be obtained using 
 * the {@link #getInstance()} method.
 * This class is in essence a map with the following characteristics:
 * <li> the key is the target class (the class to be instrumented/proxied); The target class should be either
 * 		a {@code Collection} or {@code Map} implementation. 
 * <li> the value is a {@link ObjectFactory} that can create proxy instances.
 * <br><br> 
 * Proxies generated by this class are serializable if the proxied class is serializable and it defines
 * a {@code serialVersionUid}. However the client of the proxy is responsible for loading the proxy before 
 * serialization (call a method other than {@code Object#toString()}). On deserialization the client of the proxy 
 * must ensure that the proxy class is loaded by calling {@link CollectionProxyFactory#getProxyObjectFactory(Class)};
 * <br><br>
 * This class should not be used directly by any client code except for loading a proxied class that is needed for
 * deserialization.
 * 
 * @see #newProxy(Class, Function, Object)
 * @see ProxyFactorySupport
 * @see LazyLoadInterceptor
 *  
 * @author Razvan Popian
 */
public final class CollectionProxyFactory extends ProxyFactorySupport {
	
	private final static CollectionProxyFactory collectionProxyFactory = new CollectionProxyFactory();
	
	private final CollectionLazyLoadInterceptor collectionLazyLoadInterceptor = new CollectionLazyLoadInterceptor();
	private final CollectionToStringInterceptor collectionToStringInterceptor = new CollectionToStringInterceptor();
	
	public static CollectionProxyFactory getInstance() {
		return collectionProxyFactory;
	}
	
	static final String PARENT_ID_FIELD_NAME = "com$asentinel$common$orm$proxy$collection$parent$id";
	
	/**
	 * Private constructor.
	 * Use {@link #getInstance()} for accessing the singleton instance of this class.
	 */
	private CollectionProxyFactory() {
		
	}
	
	@SuppressWarnings("unchecked")
	@Override
	protected <T> DefaultObjectFactory<? extends T> getProxyObjectFactoryInternal(Class<T> clazz) {
		Assert.assertTrue(Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz), 
				"Expected a collection or map implementation.");
		// TODO: check/make serialization/deserialization work without the presence of the dynamic class
		DefaultObjectFactory<? extends T> collectionProxyFactory = (DefaultObjectFactory<? extends T>) cache.get(clazz,
			() -> {
				checkForFinalMethods(clazz);
				// TODO: we probably should have a separate interceptor for the clear method of the collections. If clear
				// is called we should not call the loader because the collection will be cleared anyway. We would save a
				// call to the DB.
				Builder<?> byteBuddyBuilder = new ByteBuddy()
					.subclass(clazz)
					.name(CollectionProxyFactory.class.getPackage().getName() + "." + clazz.getSimpleName() + PROXY_CLASS_NAME_SUFFIX)
					// Implementation note: the loader and the parent id fields MUST be volatile, because they can potentially 
					// be set/read from multiple threads. The visibility of the lazy loaded fields
					// is ensured by synchronizing on the proxy implicit lock (see AbstractLazyLoadInterceptor and AbstractToStringInterceptor), 
					// but the loader field can be set without acquiring a lock first, for example by the method #newProxy(Class, Function, Object) 
					// in this class.
					.defineField(LOADER_FIELD_NAME, Function.class, HELPER_FIELD_MODIFIERS)
					.defineField(PARENT_ID_FIELD_NAME, Object.class, HELPER_FIELD_MODIFIERS)
					.implement(Proxy.class)
					.method(ElementMatchers.any())
					.intercept(MethodDelegation.withDefaultConfiguration().filter(ElementMatchers.named(INTERCEPTOR_METHOD_NAME)).to(collectionLazyLoadInterceptor))
					.method(ElementMatchers.isToString())
					.intercept(MethodDelegation.withDefaultConfiguration().filter(ElementMatchers.named(TO_STRING_INTERCEPTOR_METHOD_NAME)).to(collectionToStringInterceptor));
				
				Long serialVersionUid = getSerialVersionUid(clazz);
				if (serialVersionUid != null) {
					byteBuddyBuilder = byteBuddyBuilder.serialVersionUid(serialVersionUid);
				}
				
				return newObjectFactory(byteBuddyBuilder, CollectionProxyFactory.class);
			}
		);
		return collectionProxyFactory;
	}

	@Override
	protected Long getSerialVersionUid(Class<?> clazz) {
		if (!Serializable.class.isAssignableFrom(clazz)) { 
			return null;
		}
		
		// we used to introspect the value of the serialVersionUID static field in the proxy super class (ArrayList etc)
		// by calling the method ProxyFactorySupport#getSerialVersionUid, but
		// since java 11 we get an "An illegal reflective access operation has occurred" warning and we can no longer do that
		// therefore we hardcode the value. This is a best effort so that serialization/deserialization of proxies works
		// in simple scenarios
		
		// for most used collection proxies return the super class serialVersionUID so that we
		// don't break existing code that relies on that value
		if (ArrayList.class== clazz) {
			return 8683452581122892189L; 
		} else if (LinkedList.class== clazz) {
			return 876323262645176354L;
		} else if (HashSet.class== clazz) {
			return -5024744406713321676L;
		} else if (TreeSet.class== clazz) {
			return -2479143000061671589L;
		} else if (HashMap.class== clazz) {
			return 362498820763181265L;
		} else if (TreeMap.class== clazz) {
			return 919286545866124006L;
		}
		
		// for anything else return an arbitrary constant
		return 1L;
	}
	
	
	public <T> T newProxy(Class<T> targetClass, Function<Object, Collection<?>> loader, Object parentId) {
		DefaultObjectFactory<? extends T> proxyFactory = getProxyObjectFactory(targetClass);
		T proxy = proxyFactory.newObject();
		
		Field loaderField = findLoaderField(proxyFactory.getType());
		ReflectionUtils.setField(loaderField, proxy, loader);
		
		Field parentIdField = findParentIdField(proxyFactory.getType());
		ReflectionUtils.setField(parentIdField, proxy, parentId);
		
		return proxy;
	}
	
	static Field findParentIdField(Class<?> proxyClass) {
		Assert.assertNotNull(proxyClass, "proxyClass");
		Field fieldParentId = ReflectionUtils.findField(proxyClass, CollectionProxyFactory.PARENT_ID_FIELD_NAME);
		if (fieldParentId == null) {
			throw new IllegalArgumentException("Can not find the parent id field in class " + proxyClass.getName());
		}
		return fieldParentId;
	}
	
}
